下面是面向 glb 渲染的 SoftRenderer 重构方案与分阶段任务清单（不直接改代码）。重点是分层、数据流、零第三方依赖、可扩展与性能友好。

# 目标架构（软光栅最佳实践）
核心分层：Asset → Runtime → Render

## Asset 层（加载/解码/规范解析）
- glTF/GLB 解析、Buffer/Accessor 解包、Image 解码、Texture/Sampler 解析
- 不涉及渲染与运行时布局
- 产出：GLTFAsset（与规范一致、面向加载）

## Runtime 层（渲染友好数据）
- 扁平化 SOA + 对齐 + 预计算
- GPUScene / GPUMesh / GPUMaterial / GPUTexture
- glTF 坐标系转换、法线/切线修正、AABB 预计算
- 产出：可直接被渲染管线消费的数据

## Render 层（管线与调度）
- RenderQueue / TileBinning / Rasterizer / FragmentShader
- 统一的 Frame/Pass 上下文，消除临时数据结构与重复计算
- Renderer 仅做 orchestration

# 现状与关键改造点（结合当前代码）
- Renderer 集中做了相机、光源、队列、几何与光栅的全部控制逻辑，耦合高。
- Rasterizer 持有 PBRMaterial 的 per-triangle 复制，后续纹理索引化会膨胀。
- GeometryProcessor 面向当前 Mesh 结构，缺少 glTF 顶点流/SOA 与多属性管线准备。
- Scene/RenderQueue 假设模型来自本地 Mesh，缺少 glTF 资产与运行时桥接层。

# 模块清单（建议新增/重排）
## Asset/
- GLTFLoader
- GLTFTypes
- JSONParser
- BufferAccessor
- ImageDecoder

## Runtime/
- GPUScene
- GPUMesh
- GPUMaterial
- GPUTexture
- GPUSampler
- GPUNode/GPUTransform

## Render/
- RenderQueue
- TileBinning（阶段4）
- Rasterizer
- FragmentShader（新增 ShadeGLTF 路径）
- FrameContext/PassContext

# 接口草案（阶段0目标）
## Asset 层接口
- GLTFLoader::LoadGLB(path) -> GLTFAsset
- GLTFLoader::LoadGLTF(path) -> GLTFAsset
- GLTFLoader::GetLastError() -> string

## Runtime 层接口
- GPUScene::Build(const GLTFAsset& asset, int sceneIndex)
- GPUScene::GetMeshes()/GetMaterials()/GetTextures()

## Render 层接口
- Renderer::Render(const Scene& scene)
- Renderer::Render(const GPUScene& scene)
- RenderQueue::Build(const GPUScene& scene)
- Rasterizer::Rasterize(const GPUMesh& mesh, const GPUMaterial& mat, const FrameContext& ctx)

# 分阶段任务清单（为 glb 渲染准备）
## 阶段 0：架构骨架与接口稳定（1 周）
目标：不改渲染功能，先把结构“拆开”

任务清单：
1. 定义 Asset / Runtime / Render 三层 public API（头文件）
2. Renderer 中的“场景构建、默认光源、渲染队列构建”拆到独立模块
3. FrameContext/PassContext 职责边界明确化
4. RenderQueue 抽离 Renderer 的 Build 逻辑
5. 增加 GPUScene 最小骨架与占位接口（不接 glTF）

产出：
- FrameContext/PassContext 稳定
- Renderer 只做 orchestration
- RenderQueue 从 Renderer 中剥离
- GPUScene 空实现可编译

## 阶段 1：Asset 层（glTF/GLB 基础解析）（2–4 周）
目标：GLB 能完整解析为 GLTFAsset

任务清单：
1. JSONParser（递归下降）
2. BufferAccessor 解包（按 accessor 类型）
3. GLTFTypes/GLTFAsset 数据结构
4. GLTFLoader（GLB 容器 + JSON + Bin）
5. ImageDecoder（PNG/JPEG）

产出：
- GLTFAsset（buffers/images/materials/meshes/nodes/scenes）
- 错误收集与诊断机制

## 阶段 2：Runtime 层（渲染友好数据转换）（2–3 周）
目标：将 GLTFAsset 转成 GPUScene

任务清单：
1. GPUScene::Build 实现
2. SOA 顶点流 → 紧凑顶点/索引合并
3. AABB/normalMatrix 预计算
4. glTF → DirectX 坐标系转换
5. 材质扁平化 + 纹理索引化

产出：
- GPUScene 可被 Render 层消费

## 阶段 3：Render 层对接 GPUScene（2–3 周）
目标：Renderer 只面向 GPUScene，不再依赖 Asset

任务清单：
1. RenderQueue 以 GPUScene 为输入
2. Rasterizer 输入改为“顶点/材质索引 + 纹理索引”
3. FragmentShader 扩展 ShadeGLTF 流程
4. 保持旧管线兼容（调试用）

产出：
- glb 模型可渲染（基础 PBR）

## 阶段 4：性能与可扩展（2–4 周）
目标：为大场景与多材质优化

任务清单：
1. Tile-based binning
2. Mesh/Material 批次排序
3. 缓存友好布局与并行优化
4. Mipchain + 采样器

# 推荐的重构落点（现有文件对应）
- Renderer 抽离 orchestration：Renderer.cpp
- RenderQueue 由“对象驱动”转为“GPUScene 驱动”：RenderQueue.cpp
- Rasterizer 输入结构去掉重材质复制：Rasterizer.h
- GeometryProcessor 拆为“顶点变换 + 裁剪前构建 + 流输入”：GeometryProcessor.h

# 下一步执行（默认从阶段0开始）
1) 输出阶段0的文件级重构清单与依赖关系图
2) 生成阶段0的最小接口头文件清单
3) 再进入阶段1实现 glTF 资产解析